logger = require('onelog').get 'Git'

wrench = require 'wrench'
_ = require 'underscore'
fs = require 'fs'
git = require 'gift'
path = require 'path'
mkdirp = require 'mkdirp'
async = require 'async'

capitaliseFirstLetter = (str) ->
  str.charAt(0).toUpperCase() + str.slice(1)

class @Git

  # Ensure git repo exists.
  @makeGitRepo: (repoPath, done) ->
    mkdirp.sync repoPath
    await git.init repoPath, defer e, repo
    return done e if e
    done null, repo

  # Accepts act markdown as strings.
  # TODO: Maybe make #addActToGitRepo more generic?
  @addAmendedActsToGitRepo: (info, repo, acts, opts, done) =>
    _.defaults info,
      title: 'Unknown Title'

    for title, act of acts

      console.log 'Committing act:', title

      folderName = title.charAt(0).toLowerCase()
      safeActTitle = title.replace /[^a-zA-Z0-9_\-\.]/g, '-'
      subdir = path.join folderName, safeActTitle

      # Create file
      # -----------

      # Place files in a subdirectory.
      if opts.subdir?
        dest = path.join repo.path, subdir, 'index.md'
      else
        dest = path.join repo.path, 'index.md'
      mkdirp.sync path.dirname dest

      fs.writeFileSync dest, act.markdown

      # Make commit
      # -----------

      msg = "A committttt!"
      subject = "An amendment!"
      # Add file.
      await repo.add path.resolve(dest), defer e, stdout, stderr
      if e
        logger.error e
        continue
        #return done e if e

      # Commit changeset.
      await repo.commit msg, {}, defer e
      if e
        logger.error "Commit failed! Perhaps there is nothing to commit?"
        continue
        #return done e if e
      logger.debug "Committed:", subject

    done()

  # Add acts to git repo.
  @addActsToGitRepo: (repo, acts, opts, done) ->

    # For each act we will copy the file into the repo,
    # and make a commit.
    for act in acts

      unless act.output?
        logger.warn 'No output file found - nothing to add to repo'
        continue

      # Copy file
      # ---------

      src = act.output.path
      # Place files in a subdirectory.
      if opts.subdir?
        dest = path.join repo.path, opts.subdir, 'index.md'
      else
        dest = path.join repo.path, 'index.md'
      mkdirp.sync path.dirname dest

      # Check file exists.
      continue unless fs.existsSync src
      srcStats = fs.statSync src
      if fs.existsSync dest
        destStats = fs.statSync dest
        if srcStats.size is destStats.size
          logger.warn 'File was same size as existing file. Skipping.'
          continue

      fs.createReadStream(src).pipe fs.createWriteStream(dest)

      # Make commit
      # -----------

      # Prepare commit message.
      latestAmendment = act['Incorporating Amendments Up To']
      subject = unless latestAmendment is 'No records to display.'
        #"Incorporating amendments up to #{latestAmendment}"
        "#{latestAmendment} -> #{act.Title}"
      else if act['Date Prepared']
        "#{act.Title} (as of #{act['Date Prepared']})"
      else
        "#{act.Title}"

      msg = """#{subject}

        Comlaw Id: #{act.ComlawId}
        Date Prepared: #{act['Date Prepared'] or 'unknown'}
        Comlaw Consolidated Act Link: #{act['Title Link'] or 'N/A'}
        Comlaw Amendment Link: #{act['Incorporating Amendments Up To Link'] or 'N/A'}

        Format: #{act.output.compiler?.type or 'unknown'}
        Generated by: #{act.output.compiler?.name or 'unknown'} v#{act.output.compiler?.version or 0}
        """

      # Add file.
      await repo.add path.resolve(dest), defer e, stdout, stderr
      if e
        logger.error e
        continue
        #return done e if e

      # Commit changeset.
      await repo.commit msg, {}, defer e
      if e
        logger.error "Commit failed! Perhaps there is nothing to commit?"
        continue
        #return done e if e
      logger.debug "Committed:", subject

    done()


  @getPrincipalActName: (acts) ->
    # TODO: Brittle.
    parseActTitle = (title) ->
      a = (/(.*)/g.exec title)[0]
      a.replace /[ ]/g, '-'

    principalAct = acts[0]
    principalActTitle = parseActTitle principalAct.Title
    principalActTitle = principalActTitle.replace /[^a-zA-Z0-9_\-\.]/g, '-'


  # Creates a repo for a single act.
  #
  # @param [Object] acts - Must be sorted from earliest to latest.
  @makeGitRepoFromActs: (acts, opts, done) ->
    unless done? then done = opts; opts = {}
    _.defaults opts,
      # Working directory. Repo dir will be created inside this dir.
      workDir: path.join __dirname, 'tmp'
      version: 'unknown'

    # Create directory which will contain repo.
    # We name the dir after the title of the principal act.
    # The dir is overidden if it exists.
    principalActTitle = Git.getPrincipalActName acts
    repoPath = path.join opts.workDir, principalActTitle
    wrench.rmdirSyncRecursive repoPath, true
    # ---

    await Git.makeGitRepo repoPath, defer e, repo
    return done e if e
    await Git.addActsToGitRepo repo, acts, opts, defer e
    return done e if e
    logger.info 'Successfully created repo at:', repoPath
    logger.info "Inspect repo with:\nstree #{repoPath}"
